(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["QSIM`superoperators`"];

createSuperoperator::usage="createSuperoperator[processOutput,kRounds:3] takes a density matrix of dimension corresponding to 2*number of qubits to be operated on. This density matrix should be generated from carrying out the entire process to be described on one half of a series of perfect phi0 states. This function uses the Choi-Jamiolkowskii isomorphism to turn this state into a list of Kraus operators K_i and corresponding probabilities p_i to describe a superoperator S of the form: S(\[Rho])=\!\(\*SubscriptBox[\(\[CapitalSigma]\), \(i\)]\)\!\(\*SubscriptBox[\(p\), \(i\)]\)\!\(\*SubscriptBox[\(K\), \(i\)]\)\!\(\*SuperscriptBox[SubscriptBox[\(\[Rho]K\), \(i\)], \(*\)]\) . An additional optional parameter kRounds can be increased if the eigenvalue decomposition is not working correctly which can lead to spurious decompositions. Increasing this value adds further rounds of normalisation and orthogonalization of the eigenvectors. ";

applySuperoperator::usage="applySuperoperator[state,superoperator,traceOutput->True] takes a superoperator (of the form generated by the 'createSuperoperator' function) which operators on N qubits and applies it to the first (or outermost) qubits of the density matrix 'state'. The identity is applied to all other qubits. By default the output is normalized, but setting traceOutput->False";











Begin["`Private`"];

findPosition[a_]:={FromDigits[Take[a,{1,-1,2}],2]+1,FromDigits[Take[a,{2,-1,2}],2]+1}
vecToOp[v_]:=Module[{dim,empty,basis,elements,positions,values,replace},

dim=Log[2,Length[v]];
empty=ConstantArray[0,{2^(dim/2),2^(dim/2)}];
basis=IntegerDigits[#,2,dim]&/@Range[0,Length[v]-1];
elements=Thread[DeleteCases[Thread[{basis,v}],{_,0}]];
positions=findPosition[#]&/@elements[[1]];
values=elements[[2]];
replace=positions[[#]]->values[[#]]&/@Range[Length[values]];

ReplacePart[empty,replace]
]

createSuperoperator[processOutput_,kRounds_:3]:=Module[{eigensystem,eigenvalues,operators,eigenvectors},

eigensystem=Eigensystem[Normal[processOutput]];
eigenvalues=Chop[eigensystem[[1]]];

(*check eigenvalues add to 1*)
eigenvectors=Nest[Orthogonalize,Normalize[#]&/@Orthogonalize[eigensystem[[2]]],kRounds];

operators=vecToOp[#]&/@eigenvectors;

{eigenvalues,operators}
]


Options[applySuperoperator] = {traceOutput->True};
applySuperoperator[state_,superop_,OptionsPattern[]]:=Module[{dimState,dimOp,extraDimensions,ident,operators,eigenvalues,elements,out},

dimState=Log[2,Length[state]];
dimOp=Log[2,Length[superop[[1]]]]/2;

extraDimensions=dimState-dimOp;
ident=If[extraDimensions==0,{1},IdentityMatrix[2^extraDimensions]];

operators=KroneckerProduct[superop[[2,#]],ident]&/@Range[Length[superop[[1]]]];
eigenvalues=superop[[1]];
elements=#.state.ConjugateTranspose[#]&/@operators;

out=eigenvalues.elements;

If[OptionValue@traceOutput==True,out/Tr[out],out,
Message[traceOutput::usage]]
(*out/Tr[out]*)
]

End[]
EndPackage[]
