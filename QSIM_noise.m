(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["QSIMnoise`"];


applyNoisyGate::usage =" applyNoisyGate[state_,pos1_,pos2_,gate_,pg_] apply 'gate' to qubits at pos1 and pos2 and then applies random 2 qubit pauli noise of magnitude pg at those two positions"
applyGateNoise::usage="applyGateNoise[state_,pg_,pos1_,pos2_] takes a density matrix 'state' and applies 2 qubit gate noise of magnitude pg onto qubits at positions pos1 and pos2";
applySingleQubitNoise::usage="applySingleQubitNoise[\[Rho]_,pos_,err_]  takes a density matrix \[Rho] and applies a random Pauli error with probability err the qubit at position pos";
applyMemoryNoise::usage="applyMemoryNoise[\[Rho]_,pos_,pmem_,scaling_]  takes a density matrix \[Rho] and applies memory noise of magnitude pmem to the state represented by density matrix \[Rho] at positions pos";
applyRandomXZ::usage="applyRandomXZ[\[Rho]_,pos_,pXZ_]  takes a density matrix \[Rho] and applies memory noise of magnitude pXZ to the state represented by density matrix \[Rho] at position pos randomly in the X and Z channels";



Begin["`Private`"];

qsim=ParentDirectory[NotebookDirectory[]];
Get[StringJoin[qsim,"\\QSIM\\QSIM_basicFunctions.m"]]


sparseNoise[list_]:=
SparseArray[KroneckerProduct@@(SparseArray[PauliMatrix[#]]&/@list)]


applyNoisyGate[state_,pos1_,pos2_,gate_,pg_]:=Module[{size,gate2,s},

size = Log[2,Length[state]];

gate2 = twoQgate[size,pos1,pos2,gate];
s = gate2.state.CT[gate2];

s = applyGateNoise[s,pg,pos1,pos2];

s
];


applyGateNoise[state_,pg_,pos1_,pos2_]:=Module[{size,p,output,posVec,noise,count,i,j},

size=Log[2,Length[state]];
p=ReplacePart[ ConstantArray[pg/15,{4,4}],{1,1}->1-pg];

posVec[i_,j_]:=ReplacePart[ConstantArray[0,size],{pos1->i,pos2->j}];

output=ConstantArray[0,16];
count=1;

For[i=0,i<=3,i++,
For[j=0,j<=3,j++,
noise=sparseNoise[posVec[i,j]];
output[[count]]=p[[i+1,j+1]]*noise.state.ConjugateTranspose[noise];
count=count+1;

]];

Plus@@output

(*output=Sum[
p[[i+1,j+1]]*sparseNoise[posVec[i,j]].state.ConjugateTranspose[sparseNoise[posVec[i,j]]],{i,0,3},{j,0,3}]*)
]


applySingleQubitNoise[\[Rho]_,pos_,err_]:=Module[{numQ,p,id1,id2,map},
numQ=Log[2,Length[\[Rho]]];
p={1-err,err/3,err/3,err/3};
id1=SparseArray@IdentityMatrix[2^(pos-1)];
id2=SparseArray@IdentityMatrix[2^(numQ-pos)];
map=SparseArray@KroneckerProduct[id1,SparseArray@PauliMatrix[#],id2]&/@Range[0,3];

Re[Sum[p[[i]]*map[[i]].\[Rho].ConjugateTranspose[map[[i]]],{i,1,4}]]
];


applyMemoryNoise[\[Rho]_,pos_,pmem_,scaling_:1]:=Module[{numQ,id1,id2,map,front,back,p,err},

err=scaling*pmem;

numQ=Log[2,Length[\[Rho]]];
p={1-err,err/3,err/3,err/3};
id1=SparseArray@IdentityMatrix[2^(pos-1)];
id2=SparseArray@IdentityMatrix[2^(numQ-pos)];

map=SparseArray@KroneckerProduct[id1,SparseArray@PauliMatrix[#],id2]&/@Range[0,3];

Re[Sum[p[[i]]*map[[i]].\[Rho].ConjugateTranspose[map[[i]]],{i,1,4}]]

]


applyRandomXZ[\[Rho]_,pos_,pZ_]:=Module[{numQ,id1,id2,map,front,back,p,err},

err=pZ;
numQ=Log[2,Length[\[Rho]]];
p={1-err,err,0,err};
id1=SparseArray@IdentityMatrix[2^(pos-1)];
id2=SparseArray@IdentityMatrix[2^(numQ-pos)];

map=SparseArray@KroneckerProduct[id1,SparseArray@PauliMatrix[#],id2]&/@Range[0,3];

Re[Sum[p[[i]]*map[[i]].\[Rho].ConjugateTranspose[map[[i]]],{i,1,4}]]

]

End[]
EndPackage[];
