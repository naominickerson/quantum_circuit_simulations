(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["QSIMnonlocal`"];
singleSelection::usage="singleSelection[rawPair,state,{pg,pm,pmem}]  takes a state, and a noisy bell pair (rawPair) and performs a noisy parity projection onto state with error rates pg,pm and pmem";
singleParityProjectMap::usage="singleParityProjectMap[bellPair_,{pg_,pm_,pmem_}] takes a 2 qubit density matrix representing a noisy bellPair and uses it to generate a superoperator describing a parity projection.";
doubleSelection::usage="doubleSelection[bellPair1_,bellPair2_,inputState_,{pg_,pm_,pmem_}] uses two noisy bellPairs to perform a double selection parity projection on 2 qubit density matrix inputState given noise rates pg,pm and pmem.";
doubleParityProjectMap::usage="doubleParityProjectMap[bell1,bell2,{pg,pm,pmem}]  creates a superorperator to describe the action of double selection parity projection using input bell pairs bell1 and bell2 with error rates pg,pm and pmem.";
czGateMap::usage="czGateMap[bellPair,{pg,pm,pmem}] creates a superoperator describing a non-local controlled-Z gate performed on two qubits using a noisy bellPair with local error rates {pg,pm,pmem}. This superoperator can be applied to a density matrix using the applySuperoperator function";
turnMap::usage="turnMap[bellPair,{pg,pm,pmem}] creates a superoperator to perform a non-local 'turn' operation on two qubits using a noisy bellPair and local error rates {pg,pm,pmem}. The resulting superoperator can be applied to a state in density matrix form using the 'applySuperoperator' function";

Begin["`Private`"];

qsim=ParentDirectory[NotebookDirectory[]];
Get[StringJoin[qsim,"\\QSIM\\QSIM_basicFunctions.m"]]
Get[StringJoin[qsim,"\\QSIM\\QSIM_measurement.m"]]
Get[StringJoin[qsim,"\\QSIM\\QSIM_noise.m"]]
Get[StringJoin[qsim,"\\QSIM\\QSIM_superoperators.m"]]


singleSelection[rawPair_,inputState_,{pg_,pm_,pmem_}]:=Module[{state,gate1,gate2,measure,stateUpdate},

state=KP[rawPair,inputState];
gate1=twoQgate[4,1,3,cz];
gate2=twoQgate[4,2,4,cz];

(*bilateral gates followed by noise*)
state=gate1.state.CT[gate1];
state=gate2.state.CT[gate2];
state=applyGateNoise[state,pg,1,3];
state=applyGateNoise[state,pg,2,4];

(*rotate basis*)
state=KP[had,had,id,id].state.KP[had,had,id,id];

measure=Chop@measure2even[state,pm];
stateUpdate=measure/Tr[measure]
]


singleParityProjectMap[rawPair_,{pg_,pm_,pmem_}]:=Module[{state,cz1,cz2,hadamards,measure,result},

state=KP[rawPair,phi0,phi0];

cz1=twoQgate[6,1,3,cz];
cz2=twoQgate[6,2,5,cz];
state=cz1.state.CT[cz1];
state=cz2.state.CT[cz2];
state=applyGateNoise[state,pg,1,3];
state=applyGateNoise[state,pg,2,5];

hadamards=KP[had,had,id,id,id,id];
state=hadamards.state.CT[hadamards];
measure=Chop[measure2even[state,pm]];
result=measure/Tr[measure];

createSuperoperator[result]
]



doubleSelection[bellPair1_,bellPair2_,inputState_,{pg_,pm_,pmem_}]:=Module[{state,cz1,cz2,measure,hads},

state=KP[bellPair2,bellPair1,inputState];           

cz1=twoQgate[6,3,5,cz];
cz2=twoQgate[6,4,6,cz];  
state=cz1.state.CT[cz1];
state=cz2.state.CT[cz2];                                                            
state=applyGateNoise[state,pg,3,5];
state=applyGateNoise[state,pg,4,6];

cz1=twoQgate[6,1,3,cz];
cz2=twoQgate[6,2,4,cz];  
state=cz1.state.CT[cz1];
state=cz2.state.CT[cz2];
state=applyGateNoise[state,pg,1,3];
state=applyGateNoise[state,pg,2,4];

hads=KP[had,had,had,had,id,id];
state=hads.state.hads;
measure=measure2even[measure2even[state,pm],pm];

state=measure/Tr[measure]

]

doubleParityProjectMap[bell1_,bell2_,{pg_,pm_,pmem_}]:=Module[{input,state,cz1,cz2,cz3,cz4,biCZ1,biCZ2,p,hadamards,measure,output},

state=SparseArray[KP[bell1,bell2,phi0,phi0]];
(*A1B1  A2B2  A3A' B3B'*)

cz1=twoQgate[8,4,7,cz];
cz2=twoQgate[8,3,5,cz];
cz3=twoQgate[8,1,3,cz];
cz4=twoQgate[8,2,4,cz];
biCZ1=SparseArray[cz1.cz2];
biCZ2=SparseArray[cz3.cz4];

state=biCZ1.state.CT[biCZ1];

state=applyGateNoise[state,pg,4,7];
state=applyGateNoise[state,pg,3,5];

state=biCZ2.state.CT[biCZ2];
state=applyGateNoise[state,pg,1,3];
state=applyGateNoise[state,pg,2,4];

state=SparseArray[state];
hadamards=SparseArray[KP[had,had,had,had,IdentityMatrix[2^4]]];

state=hadamards.state.CT[hadamards];
measure=Chop[measure2even[measure2even[state,pm],pm]];

output=measure/Tr[measure];

createSuperoperator[output]

]



czGateMap[bellPair_,{pg_,pm_,pmem_}]:=Module[{p,state,czA,czB,bilateralCZ,aToX,bToY,rotate,measure,output,localgates},

state=KP[bellPair,phi0,phi0];

czA=twoQgate[6,1,3,cz];
czB=twoQgate[6,2,5,cz];
bilateralCZ=czA.czB;
state=bilateralCZ.state.ConjugateTranspose[bilateralCZ];

applyGateNoise[state,pg,1,3];
applyGateNoise[state,pg,2,5];

(*rotate to measurement bases*)
rotate=KP[had,hadY,IdentityMatrix[2^4]];
state=rotate.state.ConjugateTranspose[rotate];
measure=Chop@measure2even[state,pm];

output=measure/Tr[measure];

localgates=KP[sm.pX,id,sm,id];
output=localgates.output.CT[localgates];

createSuperoperator[output]

]



turnMap[bell_,{pg_,pm_,pmem_}]:=Module[{state,cz1,cz2,biCZ,hadamards,measure,gate1,mat,output},

state=KP[bell,phi0,phi0];

gate1=KP[sm,id,id,id,id,id];
cz1=twoQgate[6,1,3,cnot];
cz2=twoQgate[6,2,5,cy];
biCZ=cz1.cz2;

state=gate1.state.CT[gate1];
state=biCZ.state.CT[biCZ];

state=applyGateNoise[state,pg,1,3];
state=applyGateNoise[state,pg,2,5];

hadamards=KP[had,had,id,id,id,id];
state=hadamards.state.CT[hadamards];
measure=Chop[measure2even[state,pm]];

mat=KP[pZ,id,id,id];
state=mat.measure.mat;

output=state/Tr[state];

createSuperoperator[output]

]
End[]
EndPackage[];
