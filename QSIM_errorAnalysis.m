(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["QSIM`errorAnalysis`"];

stateBellComponents::usage="Takes a density matrix describing N qubits and decomposes it into the NQubit Bell basis. Best to display results in //MatrixForm"
errorStates4::usage="errorStates4[superoperatorState]  takes a superoperator state describing a noisy 4 qubit parity projection and decomposes in terms of odd and even projections and single qubit pauli errors. Note that this only shows errors up to 2 pauli errors and hence is not a full decomposition of the errors. Further each term shown can occur in multiple ways and number must be multiplied by their multiplicities to generate the error vector.";
errorStates3::usage="errorStates3[output_] takes the superoperator state describing a 3 qubit stabilizer measurement and extracts the proportion of errors in terms of even and odd projections and single qubit pauli errors. NOTE: this is not a full decomposition. Only terms up to 2 pauli errors are included and additionally each term may occur in multiple ways, for example {X,I,I},{I,X,I},{I,I,X} which must be included to find full error vecotr.";

Begin["`Private`"];
qsim=ParentDirectory[NotebookDirectory[]];
Get[StringJoin[qsim,"\\QSIM\\QSIM_basicFunctions.m"]]
Get[StringJoin[qsim,"\\QSIM\\QSIM_measurement.m"]]
Get[StringJoin[qsim,"\\QSIM\\QSIM_noise.m"]]
Get[StringJoin[qsim,"\\QSIM\\QSIM_superoperators.m"]]

binaryBasis[n_]:=IntegerDigits[#,2,n]&/@Range[0,2^n-1];

stateBellComponents[state_]:=Module[{errors,n,halfBasis,halfBasis2,basis,idents,errorList,errorRules, errorOperations,errorStates,labels,fidelities,basisVectors,bellVectors,bellComponents,labelParts},

n=Log[2,Length[state]];
halfBasis=binaryBasis[n][[1;;2^(n-1)]];
halfBasis2=Replace[#,{0->1,1->0},1]&/@halfBasis;
basis=ArrayFlatten[Thread[{halfBasis,halfBasis2}],1];
basisVectors=Partition[UnitVector[2^n,#]&/@((FromDigits[#,2]+1)&/@basis),2];
bellVectors=Normalize[#]&/@ArrayFlatten[({#[[1]]+#[[2]],#[[1]]-#[[2]]})&/@basisVectors,1];

labelParts=Partition[StringJoin[#]&/@(ToString[#]&/@#&/@basis),2];
labels=ArrayFlatten[({"|"<>#[[1]]<>"} + |"<>#[[2]]<>"}","|"<>#[[1]]<>"} - |"<>#[[2]]<>"}"})&/@labelParts,1];

bellComponents=#.state.#&/@bellVectors;

Sort[Thread[{labels,bellComponents}],#1[[2]]>#2[[2]]&]
]


errorStates4[output_,type_:0]:=Module[{state,pEven,pOdd,ident,eGates,eGates2,eGatesEven,eGatesOdd,eGatesEven2,eGatesOdd2,eStates,eStates2,fidelities,fidelities2,normal,labels,errorRules,errorOperations,startTime},

errorOperations={{id,id,id,id},{id,id,id,pZ},{id,id,id,pX},{id,id,id,pY},{id,id,pX,pX},{id,id,pX,pY},{id,id,pY,pY},{id,id,pX,pZ},{id,id,pY,pZ},{id,id,pZ,pZ}};

errorRules={id->"I",pX->"X",pY->"Y",pZ->"Z"};
labels=Join[Thread@Join[{ConstantArray["E",Length[errorOperations]]},Thread[errorOperations/.errorRules]],Thread@Join[{ConstantArray["O",Length[errorOperations]]},Thread[errorOperations/.errorRules]]
];

{pEven,pOdd}={projEvenMatrix[4],projOddMatrix[4]};

If[type=="X",
{pEven,pOdd}=KP[had,had,had,had].#.KP[had,had,had,had]&/@{pEven,pOdd};
];

state=rearrangeQubitsSparse[KP@@ConstantArray[SparseArray@phi0,4],"F"];

ident=SparseArray@id;
(* gates for ERROR -> STABILIZER *)
eGatesEven=SparseArray[KP[pEven,id,id,id,id].KP[#,id,id,id,id]]&/@(KP@@#&/@SparseArray[errorOperations]);
eGatesOdd=SparseArray[KP[pOdd,id,id,id,id].KP[#,id,id,id,id]]&/@(KP@@#&/@SparseArray[errorOperations]);

(* gates for STABILIZER -> ERROR *)
eGatesEven2 = SparseArray[KP[#,id,id,id,id].KP[pEven,id,id,id,id]]&/@(KP@@#&/@SparseArray[errorOperations]);
eGatesOdd2=SparseArray[KP[#,id,id,id,id].KP[pOdd,id,id,id,id]]&/@(KP@@#&/@SparseArray[errorOperations]);

eGates=SparseArray@Join[eGatesEven,eGatesOdd];
eGates2=SparseArray@Join[eGatesEven2,eGatesOdd2];

eStates=#.state.CT[#]&/@eGates;
eStates2=#.state.CT[#]&/@eGates2;

eStates=rearrangeQubitsSparse[#,"B"]&/@eStates;
eStates2=rearrangeQubitsSparse[#,"B"]&/@eStates2;
eStates=(#/Tr[#])&/@eStates;
eStates2=(#/Tr[#])&/@eStates2;
eStates=Normal[eStates];
eStates2=Normal[eStates2];

normal=Normal[output];
fidelities=N[Round[Chop[Fidelity[normal,eStates[[#]]],10^-8],10^-10]&/@Range[Length[labels]]];
fidelities2=N[Round[Chop[Fidelity[normal,eStates2[[#]]],10^-8],10^-10]&/@Range[Length[labels]]];

Thread[{fidelities,fidelities2,labels}]
(*Sort[Thread[{fidelities,labels}],#1[[1]]>#2[[1]]&]*)

]


errorStates3[output_]:=Module[{state,pEven,pOdd,eGates,eGates2,eStates,fidelities,normal,labels,errorRules,errorOperations3},

errorOperations3={{id,id,id},{id,id,pZ},{id,id,pX},{id,id,pY},{id,pX,pX},{id,pX,pY},{id,pY,pY},{id,pX,pZ},{id,pY,pZ},{id,pZ,pZ}};

pEven=projEvenMatrix[3];
pOdd=projOddMatrix[3];

errorRules={id->"I",pX->"X",pY->"Y",pZ->"Z"};
labels=Join[Thread@Join[{ConstantArray["E",Length[errorOperations3]]},Thread[errorOperations3/.errorRules]],Thread@Join[{ConstantArray["O",Length[errorOperations3]]},Thread[errorOperations3/.errorRules]]
];

state=rearrangeQubits[KP[phi0,phi0,phi0],"F"];


eGates=SparseArray[KP[pEven,id,id,id].KP[#,id,id,id]]&/@(KP@@#&/@SparseArray[errorOperations3]);
eGates2=SparseArray[KP[pOdd,id,id,id].KP[#,id,id,id]]&/@(KP@@#&/@SparseArray[errorOperations3]);

eGates=Join[eGates,eGates2];

eStates=#.state.CT[#]&/@eGates;
eStates=rearrangeQubits[#,"B"]&/@eStates;
eStates=(#/Tr[#])&/@eStates;
eStates=Normal[eStates];
normal=Normal[output];
fidelities=N[Round[Chop[Fidelity[normal,eStates[[#]]],10^-8],10^-10]&/@Range[Length[labels]]];

(*Sort[Thread[{fidelities,labels}],#1[[1]]>#2[[1]]&]*)
Thread[{fidelities,labels}]

]

End[]
EndPackage[];
