(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["QSIM`measurement`"];

measure0::usage="measure0[state] gives the resulting density matrix after a perfect '0' measurement on the first qubit of density matrix 'state'";
measure1::usage="measure1[state] gives the resulting density matrix after a perfect '1' measurement on the first qubit of density matrix 'state'";
measureOutcome::usage="measureOutcome[state,outcome] takes a density matrix input 'state' and returns the resulting density matrix after the first N qubits are measured perfectly to be in the state outcome which is a binary string.";
measureAncillaPlus::usage="measureAncillaPlus[state,pm] returns a density matrix that is the resulting state after performing a noisy measurement with a '0' result on the first qubit of an input state with measurement error rate pm.";
measureAncillaPlus::warning="this will be deprecated in favour of 'measureOutcomeReal' "
measure1Qreal::usage="measure1Qreal[state,outcome,pm] returns the resulting state after the first qubit of density matrix 'state' is measured to be in outcome=1 or 0 with measurement error rate pm.";
measureOutcomeReal::usage="measureOutcomeReal[inputState_,outcome_,pm_]";
measure2even::waring = "this will be deprecated: use the N qubit generalisation of this function, measureNQeven"
measure2even::usage="measure2even[state,pm] returns the density matrix resulting after a noisy EVEN PARITY measurement is made on the first two qubits on input density matrix 'state' with measurement error rate pm.";
measure2odd::waring = "use the N qubit generalisation of this function"
measure2odd::usage="measure2odd[state,pm] returns the density matrix resulting after a noisy ODD PARITY measurement is made on the first two qubits on input density matrix 'state' with measurement error rate pm.";


measureNQeven::usage="measureNQeven[state,n,pm] returns the resulting density matrix after the first n qubits of input density matrix 'state' are measured to be in an EVEN PARITY state with noisy measurements of rate pm";


Begin["`Private`"]

measure0[state_]:=Module[{dim},
dim=Length[state];
state[[1;;dim/2,1;;dim/2]]
]
measure1[state_]:=Module[{dim},
dim=Length[state];
state[[dim/2+1;;dim,dim/2+1;;dim]]
]


measureOut[state_]:=measure0[state]+measure1[state]
measureOutcome[state_,outcome_]:=Module[{n,i,result},
n=Length[outcome];
result=state;
For[i=1,i<=n,i++,
result=If[outcome[[i]]==0,measure0[result],measure1[result]];
 ];
result
]



measureAncillaPlus[state_,pm_]:=Module[{m0,m1,real},
Message[measureAncillaPlus::warning];
m0=measure0[state];
m1=measure1[state];
real=(1-pm)*m0+pm*m1;
real/Tr[real]
]


measure1Qreal[state_,outcome_,pm_]:=Module[{m0,m1},
If[outcome!=0&&outcome!=1,Message[measure1Qreal::usage];Return[];];

m0=measure0[state];
m1=measure1[state];
If[outcome==0,(1-pm)*m0+pm*m1,(1-pm)*m1+pm*m0]
]


measureOutcomeReal[inputState_,outcome_,pm_]:=Module[{i,n,state},

n=Length[outcome];

For[i=1,i<n+1,i++,
If[outcome[[i]]!=0&&outcome[[i]]!=1,Message[measureOutcomeReal::usage];Return[];];];

state=inputState;
For[i=1,i<n+1,i++,state=measure1Qreal[state,outcome[[i]],pm];];

state
]


measure2even[state_,pm_]:=Module[{m00,m01,m10,m11,real00,real11,update},
Message[measure2even::warning];
m00=measure1Qreal[measure1Qreal[state,0,pm],0,pm];
m11=measure1Qreal[measure1Qreal[state,1,pm],1,pm];
update=m00+m11
]


measure2odd[state_,pm_]:=Module[{m01,m10,update},
Message[measure2odd::warning];
m01=measure1Qreal[measure1Qreal[state,0,pm],1,pm];
m10=measure1Qreal[measure1Qreal[state,1,pm],0,pm];
update=m01+m10
]


measureNQeven[state_,n_,pm_]:=Module[{basis,parityBasis,probs,product,meas,pM,pEven,pOdd,stateEven,stateOdd},

basis=IntegerDigits[#,2,n]&/@Range[0,2^n-1];
parityBasis=Gather[basis,Divisible[Total[#1],2]==Divisible[Total[#2],2]&];
Plus@@(measureOutcomeReal[state,#,pm]&/@parityBasis[[1]])

]


End[]
EndPackage[];




